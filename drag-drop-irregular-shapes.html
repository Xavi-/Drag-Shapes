<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <title>drag-drop-irregular-shapes</title>
    <script src="jquery-1.3.2.js" type="text/javascript" charset="utf-8"></script>
<style type="text/css" media="screen">
    #board, 
    #board-screen
    {
        width: 500px;
        height: 500px;
    }
    
    #board
    {
        border: 1px solid black;
        position: relative;
        overflow: hidden;
    }
    
    #board-screen
    {
        position: absolute;
        border: 0px solid black;
        z-index: 999999;
    }
    
    .piece
    {
        position: absolute;
        border: 0px solid black;
        z-index: 1;
    }
    
    img
    {
        filter:progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand');
        position: absolute;
    }
    
    .marker
    {
        position: absolute;
        width: 5px;
        height: 5px;
        background: blue;
    }
</style>
</head>
<body id="drag-drop-irregular-shapes">
    Drag and drop the pieces to make a diamond 
    <div id="board">
        <img id="board-screen" alt="board" src="pics/transparent.gif" usemap="#board-def" />
        <map id="board-def" name="board-def">
            <area shape="poly" 
                  coords="100,0,100,100,150,150,100,150,100,200,0,100" 
                  shape-id="r" 
                  adj-pieces="{'c': [100, 150], 'g': [100, -50]}" 
                  img-piece="pics/diamond-puzzle-red.png"/>
            <area shape="poly" 
                  coords="0,0,50,0,50,50,150,50,150,100,100,150,0,50" 
                  shape-id="c" 
                  adj-pieces="{'y': [100, -50], 'g': [0, -200], 'r': [-100, -150]}" 
                  img-piece="pics/diamond-puzzle-cyan.png"/>
            <area shape="poly" 
                  coords="50,0,100,0,100,50,50,50,50,150,100,150,100,250,50,250,50,200,0,150,0,50" 
                  shape-id="g" 
                  adj-pieces="{'c': [0, 200], 'y': [100, 150], 'r': [-100, 50], 'o': [50, 50], 'p': [50, -50]}" 
                  img-piece="pics/diamond-puzzle-green.png"/>
            <area shape="poly" 
                  coords="0,0,50,0,50,50,100,0,200,0,50,150,50,100,0,100" 
                  shape-id="y" 
                  adj-pieces="{'c': [-100, 50], 'g': [-100, -150], 'o': [-50, -100], 'b': [50, -150]}" 
                  img-piece="pics/diamond-puzzle-yellow.png"/>
            <area shape="poly" 
                  coords="0,0,50,0,50,50,150,50,150,100,100,150,100,100,0,100" 
                  shape-id="o" 
                  adj-pieces="{'y': [50, 100], 'g': [-50, -50], 'b': [100, -50], 'p': [0, -100]}" 
                  img-piece="pics/diamond-puzzle-orange.png"/>
            <area shape="poly" 
                  coords="50,0,100,50,100,150,50,150,50,50,0,50" 
                  shape-id="p"
                  adj-pieces="{'g': [-50, 50], 'o': [0, 100], 'b': [100, 50]}" 
                  img-piece="pics/diamond-puzzle-purple.png"/> 
            <area shape="poly" 
                  coords="0,0,150,150,50,150,50,100,0,100" 
                  shape-id="b" 
                  adj-pieces="{'y': [-50, 150], 'p': [-100, -50], 'o': [-100, 50]}" 
                  img-piece="pics/diamond-puzzle-blue.png"/>
        </map>
    </div>
    <div id="out"></div>
<script type="text/javascript" charset="utf-8">
var xav = {};

(function() {
    xav.util = {};
    xav.util.rotateVector = (function() {
        var nullVec = { x: 0, y: 0 };
        
        return function(vec, angle, offset) {
            var cosAng = Math.cos(angle);
            var sinAng = Math.sin(angle);
            offset = offset || nullVec;
            
            return { x: vec.x * cosAng - vec.y * sinAng + offset.x,
                     y: vec.y * cosAng + vec.x * sinAng + offset.y };
        };
    })();

    xav.shape = {};
    xav.shape.create = function(areaElem) {
        var _points = [];
        var _listeners = { move: [], drop: [], lift: [], rotate: [] };
        
        var shape = {};
        shape.isLifted = false;
        
        // Returns object of the form {angle: float, x: int, y: int, width: int, height: int};
        shape.boundingGem = (function() {
            var minX = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY;
            var minY = Number.POSITIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
            
            var coords = $(areaElem).attr("coords");
            var tempPts = coords.split(",");
            
            for(var i = 0; i < tempPts.length; i += 2) {
                var x = Number(tempPts[i]), y = Number(tempPts[i + 1]);
                
                _points.push({ "x": x, "y": y });
                
                if (minX > x) { minX = x; }
                if (minY > y) { minY = y; }
                if (maxX < x) { maxX = x; }
                if (maxY < y) { maxY = y; }
            }
            
            return { angle: 0, x: minX, y: minY, 
                     width: maxX - minX, height: maxY - minY };
        })();
        
        shape.areaElement = areaElem;
        
        shape.getCenterPoint = (function() {
            var centerPntVec = { x: shape.boundingGem.width / 2, 
                                 y: shape.boundingGem.height / 2 };
            
            return function() {
                return xav.util.rotateVector(centerPntVec, shape.boundingGem.angle, shape.boundingGem);
            };
        })();
        
        shape.onMove = function(listener) {
            _listeners.move.push(listener);
            
            return shape;
        };
                
        shape.onDrop = function(listener) {
            _listeners.drop.push(listener);
            
            return shape;
        };
        
        shape.onLift = function(listener) {
            _listeners.lift.push(listener);
            
            return shape;
        };
        
        shape.onRotate = function(listener) {
            _listeners.rotate.push(listener);
            
            return shape;
        };
        
        // Pos is the x, y coordinates of the upper left hand corner of the bounding diamond (gem)
        shape.move = function(pos, e) { 
            var diff = { x: pos.x - shape.boundingGem.x, y: pos.y - shape.boundingGem.y };
            
            if(Math.abs(diff.x) <= 1 && Math.abs(diff.y) <= 1) { return; }
            
            for(var i = 0; i < _points.length; i++) {
                _points[i].x += diff.x; 
                _points[i].y += diff.y;
            }
            
            shape.boundingGem.x = pos.x;
            shape.boundingGem.y = pos.y;
                        
            for(i = 0; i < _listeners.move.length; i++) {
                _listeners.move[i].call(shape, e);
            }
            
            if(!shape.isLifted) { shape.drop(e); }
        };
        
        shape.drop = function(e) {
            shape.isLifted = false;
            
            var coords = [];
            for(var i = 0; i < _points.length; i++) {
                coords.push(_points[i].x);
                coords.push(_points[i].y);
            }
            $(areaElem).attr("coords", coords.join(","));
            
            for(i = 0; i < _listeners.drop.length; i++) {
                _listeners.drop[i].call(shape, e);
            }            
        };
        
        shape.lift = function(e) {
            shape.isLifted = true;
            
            for(var i = 0; i < _listeners.lift.length; i++) {
                _listeners.lift[i].call(shape, e);
            }
        };
        
        shape.rotate = (function() {
            var centerPntVec = { x: shape.boundingGem.width / 2, 
                                 y: shape.boundingGem.height / 2 };
            var centerVecs = [];
            for(var i = 0; i < _points.length; i++) {
                centerVecs.push({ x: _points[i].x - (centerPntVec.x + shape.boundingGem.x), 
                                  y: _points[i].y - (centerPntVec.y + shape.boundingGem.y) });
            }
            
            return function(angle, e) {
                var centerPoint = shape.getCenterPoint();
                
                var coords = [];
                
                var cornerPnt = xav.util.rotateVector({x: -centerPntVec.x, y: -centerPntVec.y }, angle, centerPoint);
                shape.boundingGem.x = cornerPnt.x;
                shape.boundingGem.y = cornerPnt.y;
                shape.boundingGem.angle = angle;
                for(i = 0; i < centerVecs.length; i++) {
                    _points[i] = xav.util.rotateVector(centerVecs[i], angle, centerPoint);
                    
                    coords.push(_points[i].x);
                    coords.push(_points[i].y);
                }
                $(areaElem).attr("coords", coords.join(","));
                
                for(i = 0; i < _listeners.rotate.length; i++) {
                    _listeners.rotate[i].call(shape, e);
                }
            };
        })();
        
        return shape;
    };
    
    xav.board = {};
    xav.board.create = function(boardId) {
        var shapes = {};
        
        var _mouseIsDown = false; 
        var _offset = {};
        var _movingShapeId = "";
        
        $(document)
            .mouseup(function(e) {
                if(!_mouseIsDown) { return true; }
                
                _mouseIsDown = false; 
                
                shapes[_movingShapeId].drop({ x: e.pageX + _offset.x, y: e.pageY + _offset.y }, e);
                _offset = {};
                _movingShapeId = "";
                
                return false;
            })
            .mousemove(function(e) {
                if(!_mouseIsDown) { return true; }
                
                shapes[_movingShapeId].move({ x: e.pageX + _offset.x, y: e.pageY + _offset.y }, e);
                
                return false;
            });
        
        $("#" + boardId)
            .siblings("img")
                .mousedown(function() { return false; }) // Prevent dragging cover image
            .end()
            .children("area")
                .each(function(i) {
                    var id = $(this).attr("shape-id");
                    shapes[id] = xav.shape.create(this);
                })
                .mousedown(function(e) {
                    if(_mouseIsDown) { return false; }
                    
                    _movingShapeId = $(this).attr("shape-id");
                    
                    var shape = shapes[_movingShapeId];
                    var gem = shape.boundingGem;
                    
                    _offset = { x: gem.x - e.pageX, y: gem.y - e.pageY };
                    _mouseIsDown = true;
                    
                    shape.lift({ x: e.pageX + _offset.x, y: e.pageY + _offset.y }, e);
                    
                    return false; 
                });
        
        return shapes;
    };
    
    xav.rotatable = {};
	xav.rotatable.create = function(img) {
        var _useCanvas = !img.filters;
        var _hasLoaded = false;

        var rot = {};
        
        rot.element = (function() {
            var diag = Math.round(Math.sqrt(img.width * img.width + img.height * img.height));
            
            if(!_useCanvas) {
                $(img)
                    .css("position", "absolute")
                    .wrap("<div></div>")
                    .parent("div")
                    .css({ position: "relative",
                           width: "100%", 
                           height: "100%" })
                    .wrap("<div></div>")
                    .parent("div")
                    .css({ width: diag, 
                           height: diag });
                
                return $(img).parent("div").parent("div")[0];
            }

            var cnv = $("<canvas>").attr("img-src", $(img).attr("src"));
            cnv.attr("width", diag)
               .attr("height", diag);

            var c = cnv[0].getContext("2d");
            c.translate(diag / 2,  diag / 2);

            $(img).replaceWith(cnv);

            return cnv[0];
        })();

		 rot.rotate = (function() {
            var diag = Math.round(Math.sqrt(img.width * img.width + img.height * img.height));
            if (_useCanvas) {
                var c = rot.element.getContext("2d");

                return function(rad) {
                    if (!_hasLoaded) { return;}
                    
                    c.clearRect(-diag / 2, -diag / 2, diag, diag);

                    c.save();
                    c.rotate(rad);
                    c.drawImage(img, -img.width / 2, -img.height / 2);
                    c.restore();
                };
            }
            
            var $imgElem = $(rot.element).children("div").children("img");

            var filterItem = $imgElem[0].filters.item(0);
            return function(rad) {
                if (!_hasLoaded) { return;}
                    
                var costheta = Math.cos(rad);
                var sintheta = Math.sin(rad);

                filterItem.M11 = costheta;
                filterItem.M12 = -sintheta;
                filterItem.M21 = sintheta;
                filterItem.M22 = costheta;
                
                $imgElem.css({ left: Math.round(diag - $imgElem.width()) / 2, 
                               top: Math.round(diag - $imgElem.height()) / 2 });
            };
		 })();
		 
		 _hasLoaded = true; 
         rot.rotate(0);
		 return rot;
	};
    
    xav.puzzle = {};
    xav.puzzle.create = function(shapes) {
        var _threshold = 10;
        var _thresholdAngle = .1;
        
        var addDisplayer = function(shape) {
            var gem = shape.boundingGem;
            var img = new Image();
            img.src = $(shape.areaElement).attr("img-piece");
            
            $(img).prependTo("#board");
            
            var rot = xav.rotatable.create(img);
            var rotStyle = rot.element.style;
            $(rot.element).addClass("piece");
            
            var halfDiag = Math.sqrt(gem.width * gem.width + gem.height * gem.height) / 2;
            shape.onMove(function(e) {
                var centerPoint = shape.getCenterPoint();
                
                rotStyle.left = (centerPoint.x - halfDiag) + "px";
                rotStyle.top = (centerPoint.y - halfDiag) + "px";
            });
            
            shape.onRotate(function(e) {
                rot.rotate(gem.angle);
            });
            
            shape.move({x: Math.round(Math.random() * (500 - gem.width)), 
                        y: Math.round(Math.random() * (500 - gem.height))});
        };
                
        var connectShapes = function(shape1, shape2, vec) {
            var gem1 = shape1.boundingGem;
            var gem2 = shape2.boundingGem;
            
            shape1
                .onLift(function(e) { if(!shape2.isLifted) {  shape2.lift(e); } })
                .onMove(function(e) {
                    var pos = { x: gem1.x + vec.x, y: gem1.y + vec.y };
                    
                    if(Math.abs(gem2.x - pos.x) <= .5 && Math.abs(gem2.y - pos.y) <= .5) { return; }
                    
                    shape2.move(pos);
                })
                .onDrop(function(e) { if(shape2.isLifted) { shape2.drop(e); } });
            
            var negVec = { x: -vec.x, y: -vec.y };
            shape2
                .onLift(function(e) { if(!shape1.isLifted) { shape1.lift(e); } })
                .onMove(function(e) {
                    var pos = { x: gem2.x + negVec.x, y: gem2.y + negVec.y };
                    
                    if(Math.abs(gem1.x - pos.x) <= .5 && Math.abs(gem1.y - pos.y) <= .5) { return; }
                    
                    shape1.move(pos);
                })
                .onDrop(function(e) { if(shape1.isLifted) { shape1.drop(e); } });
        };
        
        var addAdjacencyCheck = function(shape, adjList) {
            var thisGem = shape.boundingGem;
            
            shape.onDrop(function(e) {
                for (var id in adjList) {
                    if (!adjList[id]) { continue; }
                    
                    var thatGem = shapes[id].boundingGem;
                    if(Math.abs(thisGem.angle - thatGem.angle) > _thresholdAngle) { continue; }
                    
                    var truVec = xav.util.rotateVector({ x: adjList[id][0], y: adjList[id][1] }, thisGem.angle);
                    var curVec = { x: thatGem.x - thisGem.x, y: thatGem.y - thisGem.y };
                    var diff = { x: Math.abs(curVec.x - truVec.x), y: Math.abs(curVec.y - truVec.y) };
                    
                    if (diff.x < _threshold && diff.y < _threshold) {
                        var setPos = { x: thatGem.x - truVec.x, y: thatGem.y - truVec.y };
                        
                        delete adjList[id];
                        
                        this.move(setPos);
                        connectShapes(this, shapes[id], truVec);
                    }
                }
            });
        };
        
        for (var shapeId in shapes) {
            var adj = eval("(" + $(shapes[shapeId].areaElement).attr("adj-pieces") + ")");
            
            addAdjacencyCheck(shapes[shapeId], adj);
            
            addDisplayer(shapes[shapeId]);
            
            shapes[shapeId].rotate(Math.PI / 5);
        }
    };
    
    var shapes = xav.board.create("board-def");
    xav.puzzle.create(shapes);
})();
</script>
</body>
</html>